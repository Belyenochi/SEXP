// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var SExp$ReactTemplate = require("./SExp.bs.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var Imposible = Caml_exceptions.create("Eval-ReactTemplate.Imposible");

var Invalid = Caml_exceptions.create("Eval-ReactTemplate.Invalid");

var $great$eq$great = List.rev_append;

function purgeEnv(num, env) {
  var loop = function (_param) {
    while(true) {
      var param = _param;
      var n = param[0];
      if (n !== 0) {
        var match = param[1];
        if (match) {
          _param = /* tuple */[
            n - 1 | 0,
            match[1]
          ];
          continue ;
        } else {
          throw Invalid;
        }
      } else {
        return param[1];
      }
    };
  };
  return List.rev(loop(/* tuple */[
                  num,
                  List.rev(env)
                ]));
}

function isValid(text) {
  return (/(?:-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(?:true|false)|null/g).test(text);
}

function isOperator(text) {
  return (/\+|-|\*|\/|<|>|&&|\|\|/g).test(text);
}

var jseval = function (op,a,b){return eval(a+op+b)+''};

var isTrue = Curry._1(function (x,a){return x+!!a;}, "");

function Make(Ctx) {
  $$Map.Make([$$String.compare]);
  var evalList = function (ctx, env, list) {
    var err = List.fold_left((function (p, a) {
            var exit = 0;
            if (p.tag) {
              return p;
            } else {
              var match = p[0];
              if (match.tag && !a.tag) {
                return /* Result */Block.__(0, [/* List */Block.__(1, [/* :: */[
                                a[0],
                                match[0]
                              ]])]);
              } else {
                exit = 1;
              }
            }
            if (exit === 1) {
              if (a.tag) {
                return a;
              } else {
                return /* Error */Block.__(1, [/* Atom */Block.__(0, ["InvalidEval"])]);
              }
            }
            
          }), /* Result */Block.__(0, [/* List */Block.__(1, [/* [] */0])]), List.map((function (param) {
                return $$eval(ctx, env, param);
              }), list));
    if (err.tag) {
      return err;
    } else {
      var match = err[0];
      if (match.tag) {
        return /* Result */Block.__(0, [/* List */Block.__(1, [List.rev(match[0])])]);
      } else {
        throw Invalid;
      }
    }
  };
  var $$eval = function (ctx, env, _src) {
    while(true) {
      var src = _src;
      if (src.tag) {
        var match = src[0];
        if (match) {
          var fn = match[0];
          if (fn.tag) {
            var match$1 = fn[0];
            var exit = 0;
            if (match$1) {
              var match$2 = match$1[0];
              if (match$2.tag || match$2[0] !== "fun") {
                exit = 1;
              } else {
                var match$3 = match$1[1];
                if (match$3) {
                  var match$4 = match$3[0];
                  if (match$4.tag) {
                    var real = match[1];
                    var body = match$3[1];
                    var params = match$4[0];
                    if (List.length(real) > List.length(params)) {
                      return /* Error */Block.__(1, [/* List */Block.__(1, [/* :: */[
                                      /* Atom */Block.__(0, ["InvalidCall"]),
                                      /* :: */[
                                        fn,
                                        /* [] */0
                                      ]
                                    ]])]);
                    } else {
                      var _prev = /* [] */0;
                      var _param = /* tuple */[
                        params,
                        real
                      ];
                      while(true) {
                        var param = _param;
                        var prev = _prev;
                        var list = param[0];
                        var exit$1 = 0;
                        if (list) {
                          var match$5 = list[0];
                          if (match$5.tag) {
                            exit$1 = 1;
                          } else {
                            var match$6 = param[1];
                            if (match$6) {
                              _param = /* tuple */[
                                list[1],
                                match$6[1]
                              ];
                              _prev = /* :: */[
                                /* tuple */[
                                  match$5[0],
                                  match$6[0]
                                ],
                                prev
                              ];
                              continue ;
                            } else {
                              exit$1 = 1;
                            }
                          }
                        } else if (param[1]) {
                          return /* Error */Block.__(1, [/* Atom */Block.__(0, ["InvalidFunction"])]);
                        } else {
                          return $$eval(ctx, env, /* List */Block.__(1, [/* :: */[
                                          /* Atom */Block.__(0, ["let"]),
                                          /* :: */[
                                            /* List */Block.__(1, [List.map((function (param) {
                                                        return /* List */Block.__(1, [/* :: */[
                                                                    /* Atom */Block.__(0, [param[0]]),
                                                                    /* :: */[
                                                                      param[1],
                                                                      /* [] */0
                                                                    ]
                                                                  ]]);
                                                      }), prev)]),
                                            body
                                          ]
                                        ]]));
                        }
                        if (exit$1 === 1) {
                          if (param[1]) {
                            return /* Error */Block.__(1, [/* Atom */Block.__(0, ["InvalidFunction"])]);
                          } else {
                            return /* Result */Block.__(0, [/* List */Block.__(1, [/* :: */[
                                            /* Atom */Block.__(0, ["fun"]),
                                            /* :: */[
                                              /* List */Block.__(1, [list]),
                                              /* :: */[
                                                /* List */Block.__(1, [/* :: */[
                                                      /* Atom */Block.__(0, ["let"]),
                                                      /* :: */[
                                                        /* List */Block.__(1, [List.map((function (param) {
                                                                    return /* List */Block.__(1, [/* :: */[
                                                                                /* Atom */Block.__(0, [param[0]]),
                                                                                /* :: */[
                                                                                  param[1],
                                                                                  /* [] */0
                                                                                ]
                                                                              ]]);
                                                                  }), prev)]),
                                                        body
                                                      ]
                                                    ]]),
                                                /* [] */0
                                              ]
                                            ]
                                          ]])]);
                          }
                        }
                        
                      };
                    }
                  } else {
                    exit = 1;
                  }
                } else {
                  exit = 1;
                }
              }
            } else {
              exit = 1;
            }
            if (exit === 1) {
              var err = $$eval(ctx, env, fn);
              if (err.tag) {
                return err;
              } else {
                _src = /* List */Block.__(1, [/* :: */[
                      err[0],
                      match[1]
                    ]]);
                continue ;
              }
            }
            
          } else {
            var sp = fn[0];
            var exit$2 = 0;
            var exit$3 = 0;
            var exit$4 = 0;
            switch (sp) {
              case "clear" : 
                  if (match[1]) {
                    exit$4 = 3;
                  } else {
                    Curry._1(Ctx[/* clear */0], ctx);
                    return /* Result */Block.__(0, [SExp$ReactTemplate.empty]);
                  }
                  break;
              case "debug" : 
                  var err$1 = evalList(ctx, env, match[1]);
                  if (err$1.tag) {
                    return err$1;
                  } else {
                    Curry._2(Ctx[/* << */1], ctx, err$1[0]);
                    return /* Result */Block.__(0, [SExp$ReactTemplate.empty]);
                  }
              case "dump" : 
                  if (match[1]) {
                    exit$4 = 3;
                  } else {
                    return /* Result */Block.__(0, [/* List */Block.__(1, [List.map((function (param) {
                                          return /* List */Block.__(1, [/* :: */[
                                                      /* Atom */Block.__(0, [param[0]]),
                                                      /* :: */[
                                                        param[1],
                                                        /* [] */0
                                                      ]
                                                    ]]);
                                        }), env)])]);
                  }
                  break;
              case "eval" : 
                  return evalList(ctx, env, match[1]);
              case "let" : 
                  var match$7 = match[1];
                  if (match$7) {
                    var match$8 = match$7[0];
                    if (match$8.tag) {
                      var loop = function (_prev, _param) {
                        while(true) {
                          var param = _param;
                          var prev = _prev;
                          if (param) {
                            var match = param[0];
                            if (match.tag) {
                              var match$1 = match[0];
                              if (match$1) {
                                var match$2 = match$1[0];
                                if (match$2.tag) {
                                  throw Invalid;
                                } else {
                                  var match$3 = match$1[1];
                                  if (match$3) {
                                    if (match$3[1]) {
                                      throw Invalid;
                                    } else {
                                      var match$4 = $$eval(ctx, env, match$3[0]);
                                      if (match$4.tag) {
                                        throw Invalid;
                                      } else {
                                        _param = param[1];
                                        _prev = /* :: */[
                                          /* tuple */[
                                            match$2[0],
                                            match$4[0]
                                          ],
                                          prev
                                        ];
                                        continue ;
                                      }
                                    }
                                  } else {
                                    throw Invalid;
                                  }
                                }
                              } else {
                                throw Invalid;
                              }
                            } else {
                              throw Invalid;
                            }
                          } else {
                            return prev;
                          }
                        };
                      };
                      var exit$5 = 0;
                      var nenv;
                      try {
                        nenv = loop(env, match$8[0]);
                        exit$5 = 4;
                      }
                      catch (exn){
                        if (exn === Invalid) {
                          return /* Error */Block.__(1, [/* Atom */Block.__(0, ["InvalidLet"])]);
                        } else {
                          throw exn;
                        }
                      }
                      if (exit$5 === 4) {
                        var _param$1 = match$7[1];
                        while(true) {
                          var param$1 = _param$1;
                          if (param$1) {
                            var tl = param$1[1];
                            var only = param$1[0];
                            if (tl) {
                              $$eval(ctx, nenv, only);
                              _param$1 = tl;
                              continue ;
                            } else {
                              return $$eval(ctx, nenv, only);
                            }
                          } else {
                            return /* Error */Block.__(1, [/* Atom */Block.__(0, ["InvalidLetBody"])]);
                          }
                        };
                      }
                      
                    } else {
                      exit$4 = 3;
                    }
                  } else {
                    exit$2 = 1;
                  }
                  break;
              case "quote" : 
                  var match$9 = match[1];
                  if (match$9) {
                    if (match$9[1]) {
                      exit$4 = 3;
                    } else {
                      return /* Result */Block.__(0, [match$9[0]]);
                    }
                  } else {
                    exit$2 = 1;
                  }
                  break;
              case "string" : 
                  var match$10 = match[1];
                  if (match$10) {
                    var match$11 = match$10[0];
                    if (match$11.tag && !match$10[1]) {
                      return /* Result */Block.__(0, [/* Atom */Block.__(0, [$$String.concat("", List.map((function (param) {
                                                if (param.tag) {
                                                  if (param[0]) {
                                                    return "";
                                                  } else {
                                                    return " ";
                                                  }
                                                } else {
                                                  return param[0];
                                                }
                                              }), match$11[0]))])]);
                    } else {
                      exit$4 = 3;
                    }
                  } else {
                    exit$2 = 1;
                  }
                  break;
              default:
                exit$4 = 3;
            }
            if (exit$4 === 3) {
              var match$12 = match[1];
              if (match$12) {
                var match$13 = match$12[1];
                if (match$13 && !match$13[1]) {
                  var b = match$13[0];
                  var a = match$12[0];
                  if (isOperator(sp)) {
                    var proc = (function(a){
                    return function proc(fn, x) {
                      var err = $$eval(ctx, env, x);
                      if (err.tag) {
                        return err;
                      } else {
                        var match = err[0];
                        var exit = 0;
                        if (match.tag) {
                          exit = 1;
                        } else {
                          var xv = match[0];
                          if (isValid(xv)) {
                            return Curry._1(fn, xv);
                          } else {
                            exit = 1;
                          }
                        }
                        if (exit === 1) {
                          return /* Error */Block.__(1, [/* List */Block.__(1, [/* :: */[
                                          /* Atom */Block.__(0, ["FailedToConvert"]),
                                          /* :: */[
                                            a,
                                            /* [] */0
                                          ]
                                        ]])]);
                        }
                        
                      }
                    }
                    }(a));
                    return proc((function(sp,b){
                              return function (av) {
                                return proc((function (bv) {
                                              return /* Result */Block.__(0, [/* Atom */Block.__(0, [jseval(sp, av, bv)])]);
                                            }), b);
                              }
                              }(sp,b)), a);
                  } else {
                    exit$3 = 2;
                  }
                } else {
                  exit$3 = 2;
                }
              } else {
                exit$2 = 1;
              }
            }
            if (exit$3 === 2) {
              switch (sp) {
                case "define" : 
                    var match$14 = match[1];
                    var match$15 = match$14[0];
                    if (match$15.tag) {
                      exit$2 = 1;
                    } else {
                      var match$16 = match$14[1];
                      if (match$16 && !match$16[1]) {
                        var name = match$15[0];
                        var err$2 = $$eval(ctx, env, match$16[0]);
                        if (err$2.tag) {
                          return err$2;
                        } else {
                          var rst = err$2[0];
                          Curry._2(Ctx[/* <~ */3], ctx, /* tuple */[
                                name,
                                rst
                              ]);
                          return /* Result */Block.__(0, [/* List */Block.__(1, [/* :: */[
                                          /* Atom */Block.__(0, ["defined"]),
                                          /* :: */[
                                            /* List */Block.__(1, [/* :: */[
                                                  /* Atom */Block.__(0, ["quote"]),
                                                  /* :: */[
                                                    /* Atom */Block.__(0, [name]),
                                                    /* [] */0
                                                  ]
                                                ]]),
                                            /* :: */[
                                              rst,
                                              /* [] */0
                                            ]
                                          ]
                                        ]])]);
                        }
                      } else {
                        exit$2 = 1;
                      }
                    }
                    break;
                case "fun" : 
                    var match$17 = match[1];
                    var match$18 = match$17[0];
                    if (match$18.tag) {
                      var body$1 = match$17[1];
                      var exit$6 = 0;
                      if (body$1) {
                        var match$19 = body$1[0];
                        if (match$19.tag) {
                          var match$20 = match$19[0];
                          if (match$20) {
                            var match$21 = match$20[0];
                            if (match$21.tag || match$21[0] !== "let") {
                              exit$6 = 3;
                            } else {
                              var match$22 = match$20[1];
                              if (match$22 && match$22[0].tag && !body$1[1]) {
                                return /* Result */Block.__(0, [src]);
                              } else {
                                exit$6 = 3;
                              }
                            }
                          } else {
                            exit$6 = 3;
                          }
                        } else {
                          exit$6 = 3;
                        }
                      } else {
                        exit$6 = 3;
                      }
                      if (exit$6 === 3) {
                        return /* Result */Block.__(0, [/* List */Block.__(1, [/* :: */[
                                        /* Atom */Block.__(0, ["fun"]),
                                        /* :: */[
                                          /* List */Block.__(1, [match$18[0]]),
                                          /* :: */[
                                            /* List */Block.__(1, [/* :: */[
                                                  /* Atom */Block.__(0, ["let"]),
                                                  /* :: */[
                                                    /* List */Block.__(1, [List.map((function (param) {
                                                                return /* List */Block.__(1, [/* :: */[
                                                                            /* Atom */Block.__(0, [param[0]]),
                                                                            /* :: */[
                                                                              param[1],
                                                                              /* [] */0
                                                                            ]
                                                                          ]]);
                                                              }), purgeEnv(Curry._1(Ctx[/* count */4], ctx), env))]),
                                                    body$1
                                                  ]
                                                ]]),
                                            /* [] */0
                                          ]
                                        ]
                                      ]])]);
                      }
                      
                    } else {
                      exit$2 = 1;
                    }
                    break;
                default:
                  exit$2 = 1;
              }
            }
            if (exit$2 === 1) {
              if (List.mem_assoc(sp, env)) {
                _src = /* List */Block.__(1, [/* :: */[
                      List.assoc(sp, env),
                      match[1]
                    ]]);
                continue ;
              } else {
                return /* Error */Block.__(1, [/* Atom */Block.__(0, ["NotFound"])]);
              }
            }
            
          }
        } else {
          return /* Result */Block.__(0, [src]);
        }
      } else {
        var name$1 = src[0];
        if (isValid(name$1)) {
          return /* Result */Block.__(0, [src]);
        } else {
          var exit$7 = 0;
          var data;
          try {
            data = List.assoc(name$1, env);
            exit$7 = 1;
          }
          catch (exn$1){
            if (exn$1 === Caml_builtin_exceptions.not_found) {
              return /* Error */Block.__(1, [/* List */Block.__(1, [/* :: */[
                              /* Atom */Block.__(0, ["SymbolNotFound"]),
                              /* :: */[
                                /* Atom */Block.__(0, [name$1]),
                                /* [] */0
                              ]
                            ]])]);
            } else {
              throw exn$1;
            }
          }
          if (exit$7 === 1) {
            return /* Result */Block.__(0, [data]);
          }
          
        }
      }
    };
  };
  return /* module */[/* eval */$$eval];
}

exports.Imposible = Imposible;
exports.Invalid = Invalid;
exports.$great$eq$great = $great$eq$great;
exports.purgeEnv = purgeEnv;
exports.isValid = isValid;
exports.isOperator = isOperator;
exports.jseval = jseval;
exports.isTrue = isTrue;
exports.Make = Make;
/* isTrue Not a pure module */
