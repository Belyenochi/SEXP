// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var SExp$ReactTemplate = require("./SExp.bs.js");

var Imposible = Caml_exceptions.create("Eval-ReactTemplate.Imposible");

var Invalid = Caml_exceptions.create("Eval-ReactTemplate.Invalid");

var DefineMap = $$Map.Make([$$String.compare]);

function $eq$eq$great(params, body) {
  return /* record */[
          /* params */params,
          /* body */body
        ];
}

function isValid(text) {
  return (/(?:-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(?:true|false)|null/g).test(text);
}

function Make(Ctx) {
  $$Map.Make([$$String.compare]);
  var $$eval = function (ctx, src) {
    if (src.tag) {
      var match = src[0];
      if (match) {
        var match$1 = match[0];
        if (match$1.tag) {
          return /* Error */Block.__(1, [/* Atom */Block.__(0, ["NotFound"])]);
        } else {
          switch (match$1[0]) {
            case "clear" : 
                if (match[1]) {
                  return /* Error */Block.__(1, [/* Atom */Block.__(0, ["NotFound"])]);
                } else {
                  Curry._1(Ctx[/* clear */0], ctx);
                  return /* Result */Block.__(0, [SExp$ReactTemplate.empty]);
                }
            case "debug" : 
                var vals = List.fold_left((function (p, a) {
                        var exit = 0;
                        if (p.tag) {
                          return p;
                        } else {
                          var match = p[0];
                          if (match.tag && !a.tag) {
                            return /* Result */Block.__(0, [/* List */Block.__(1, [/* :: */[
                                            a[0],
                                            match[0]
                                          ]])]);
                          } else {
                            exit = 1;
                          }
                        }
                        if (exit === 1) {
                          if (a.tag) {
                            return a;
                          } else {
                            return /* Error */Block.__(1, [/* Atom */Block.__(0, ["InvalidEval"])]);
                          }
                        }
                        
                      }), /* Result */Block.__(0, [/* List */Block.__(1, [/* [] */0])]), List.map((function (param) {
                            return $$eval(ctx, param);
                          }), match[1]));
                if (vals.tag) {
                  return vals;
                } else {
                  var match$2 = vals[0];
                  if (match$2.tag) {
                    Curry._2(Ctx[/* << */1], ctx, /* List */Block.__(1, [List.rev(match$2[0])]));
                    return /* Result */Block.__(0, [SExp$ReactTemplate.empty]);
                  } else {
                    throw Invalid;
                  }
                }
            case "define" : 
                var match$3 = match[1];
                if (match$3) {
                  var match$4 = match$3[0];
                  if (match$4.tag) {
                    var match$5 = match$4[0];
                    if (match$5) {
                      var match$6 = match$5[0];
                      if (match$6.tag) {
                        return /* Error */Block.__(1, [/* Atom */Block.__(0, ["NotFound"])]);
                      } else {
                        var body = match$3[1];
                        var params = match$5[1];
                        var name = match$6[0];
                        if (List.for_all((function (param) {
                                  return param.tag ? false : true;
                                }), params)) {
                          Curry._2(Ctx[/* <~ */3], ctx, /* tuple */[
                                name,
                                /* record */[
                                  /* params */List.map((function (param) {
                                          if (param.tag) {
                                            throw Invalid;
                                          } else {
                                            return param[0];
                                          }
                                        }), params),
                                  /* body */body
                                ]
                              ]);
                          return /* Result */Block.__(0, [/* List */Block.__(1, [/* :: */[
                                          /* Atom */Block.__(0, ["defined"]),
                                          /* :: */[
                                            /* List */Block.__(1, [/* :: */[
                                                  /* Atom */Block.__(0, ["quote"]),
                                                  /* :: */[
                                                    /* Atom */Block.__(0, [name]),
                                                    /* [] */0
                                                  ]
                                                ]]),
                                            /* :: */[
                                              /* List */Block.__(1, [/* :: */[
                                                    /* Atom */Block.__(0, ["quote"]),
                                                    /* :: */[
                                                      /* List */Block.__(1, [params]),
                                                      /* [] */0
                                                    ]
                                                  ]]),
                                              /* :: */[
                                                /* List */Block.__(1, [/* :: */[
                                                      /* Atom */Block.__(0, ["quote"]),
                                                      /* :: */[
                                                        /* List */Block.__(1, [body]),
                                                        /* [] */0
                                                      ]
                                                    ]]),
                                                /* [] */0
                                              ]
                                            ]
                                          ]
                                        ]])]);
                        } else {
                          return /* Error */Block.__(1, [/* Atom */Block.__(0, ["InvalidDefine"])]);
                        }
                      }
                    } else {
                      return /* Error */Block.__(1, [/* Atom */Block.__(0, ["NotFound"])]);
                    }
                  } else {
                    var match$7 = match$3[1];
                    if (match$7) {
                      if (match$7[1]) {
                        return /* Error */Block.__(1, [/* Atom */Block.__(0, ["NotFound"])]);
                      } else {
                        var name$1 = match$4[0];
                        var err = $$eval(ctx, match$7[0]);
                        if (err.tag) {
                          return err;
                        } else {
                          var rst = err[0];
                          Curry._2(Ctx[/* <~ */3], ctx, /* tuple */[
                                name$1,
                                /* record */[
                                  /* params : [] */0,
                                  /* body : :: */[
                                    rst,
                                    /* [] */0
                                  ]
                                ]
                              ]);
                          return /* Result */Block.__(0, [/* List */Block.__(1, [/* :: */[
                                          /* Atom */Block.__(0, ["defined"]),
                                          /* :: */[
                                            /* List */Block.__(1, [/* :: */[
                                                  /* Atom */Block.__(0, ["quote"]),
                                                  /* :: */[
                                                    /* Atom */Block.__(0, [name$1]),
                                                    /* [] */0
                                                  ]
                                                ]]),
                                            /* :: */[
                                              /* List */Block.__(1, [/* :: */[
                                                    /* Atom */Block.__(0, ["quote"]),
                                                    /* :: */[
                                                      /* List */Block.__(1, [/* [] */0]),
                                                      /* [] */0
                                                    ]
                                                  ]]),
                                              /* :: */[
                                                /* List */Block.__(1, [/* :: */[
                                                      /* Atom */Block.__(0, ["quote"]),
                                                      /* :: */[
                                                        rst,
                                                        /* [] */0
                                                      ]
                                                    ]]),
                                                /* [] */0
                                              ]
                                            ]
                                          ]
                                        ]])]);
                        }
                      }
                    } else {
                      return /* Error */Block.__(1, [/* Atom */Block.__(0, ["NotFound"])]);
                    }
                  }
                } else {
                  return /* Error */Block.__(1, [/* Atom */Block.__(0, ["NotFound"])]);
                }
            case "quote" : 
                var match$8 = match[1];
                if (match$8) {
                  if (match$8[1]) {
                    return /* Error */Block.__(1, [/* Atom */Block.__(0, ["NotFound"])]);
                  } else {
                    return /* Result */Block.__(0, [match$8[0]]);
                  }
                } else {
                  return /* Error */Block.__(1, [/* Atom */Block.__(0, ["NotFound"])]);
                }
            case "string" : 
                var match$9 = match[1];
                if (match$9) {
                  var match$10 = match$9[0];
                  if (match$10.tag) {
                    if (match$9[1]) {
                      return /* Error */Block.__(1, [/* Atom */Block.__(0, ["NotFound"])]);
                    } else {
                      return /* Result */Block.__(0, [/* Atom */Block.__(0, [$$String.concat("", List.map((function (param) {
                                                if (param.tag) {
                                                  if (param[0]) {
                                                    return "";
                                                  } else {
                                                    return " ";
                                                  }
                                                } else {
                                                  return param[0];
                                                }
                                              }), match$10[0]))])]);
                    }
                  } else {
                    return /* Error */Block.__(1, [/* Atom */Block.__(0, ["NotFound"])]);
                  }
                } else {
                  return /* Error */Block.__(1, [/* Atom */Block.__(0, ["NotFound"])]);
                }
            default:
              return /* Error */Block.__(1, [/* Atom */Block.__(0, ["NotFound"])]);
          }
        }
      } else {
        return /* Result */Block.__(0, [src]);
      }
    } else {
      var name$2 = src[0];
      if (isValid(name$2)) {
        return /* Result */Block.__(0, [src]);
      } else {
        var match$11 = Curry._2(Ctx[/* % */4], ctx, name$2);
        if (match$11) {
          var match$12 = match$11[0];
          var params$1 = match$12[/* params */0];
          var exit = 0;
          if (params$1) {
            exit = 1;
          } else {
            var match$13 = match$12[/* body */1];
            if (match$13 && !match$13[1]) {
              return /* Result */Block.__(0, [match$13[0]]);
            } else {
              exit = 1;
            }
          }
          if (exit === 1) {
            return /* Result */Block.__(0, [/* List */Block.__(1, [/* :: */[
                            /* Atom */Block.__(0, ["lambda"]),
                            /* :: */[
                              /* List */Block.__(1, [List.map((function (x) {
                                          return /* Atom */Block.__(0, [x]);
                                        }), params$1)]),
                              /* :: */[
                                /* List */Block.__(1, [match$12[/* body */1]]),
                                /* [] */0
                              ]
                            ]
                          ]])]);
          }
          
        } else {
          return /* Error */Block.__(1, [/* Atom */Block.__(0, ["SymbolNotFound"])]);
        }
      }
    }
  };
  return /* module */[/* eval */$$eval];
}

exports.Imposible = Imposible;
exports.Invalid = Invalid;
exports.DefineMap = DefineMap;
exports.$eq$eq$great = $eq$eq$great;
exports.isValid = isValid;
exports.Make = Make;
/* DefineMap Not a pure module */
